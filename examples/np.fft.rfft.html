<!DOCTYPE html><html lang="en"><head>    <meta charset="UTF-8">    <title>numpy.fft.rfft</title>    <link rel="stylesheet" href="http://www.52phm.cn/static/bootstrap.min.css">    <script src="http://www.52phm.cn/static/bootstrap.min.js"></script></head><body style="background:#eaeaea"><div class="container body-main">      <div class="col-md-2" role="complementary">             <div class="media" style="background-color:#f5f5f5;width:auto;min-height:350px;color:black;background:#f8f8f8;padding:10px;box-shadow:0px 0px 3px 3px #f0f0f0">                    <p style="text-align:left;line-height:25px;"><a href="#Parameters"><img src="http://www.52phm.cn/media/editor/reply.svg"> Parameters</a></p><br><p style="text-align:left;line-height:25px;"><a href="#Returns"><img src="http://www.52phm.cn/media/editor/reply.svg"> Returns</a></p><br><p style="text-align:left;line-height:25px;"><a href="#Raises"><img src="http://www.52phm.cn/media/editor/reply.svg"> Raises</a></p><br><p style="text-align:left;line-height:25px;"><a href="#See Also"><img src="http://www.52phm.cn/media/editor/reply.svg"> See Also</a></p><br><p style="text-align:left;line-height:25px;"><a href="#Notes"><img src="http://www.52phm.cn/media/editor/reply.svg"> Notes</a></p><br><p style="text-align:left;line-height:25px;"><a href="#Examples"><img src="http://www.52phm.cn/media/editor/reply.svg"> Examples</a></p>            </div>      </div>      <div class="col-md-7" role="main">             <div class="media" style="width:auto; height:auto;color:black;background:#f8f8f8;padding:10px;box-shadow:0px 0px 3px 3px #f0f0f0">                    <h3>numpy.fft.rfft</h3><br>Help on function rfft in module numpy.fft<br><br><div style="background-color:#fbe54e">rfft(a, n=None, axis=-1, norm=None)<br>    </div><br>Compute the one-dimensional discrete Fourier Transform for real input.<br>    <br>    This function computes the one-dimensional *n*-point discrete Fourier<br>    Transform (DFT) of a real-valued array by means of an efficient algorithm<br>    called the Fast Fourier Transform (FFT).<br>    <br><a name="Parameters"></a><h3>Parameters</h3><div style="background-color:#f2eadd;"><div style="margin-left:1.5em;">    a : array_like<br>&emsp;&emsp;Input array<br>    n : int, optional<br>&emsp;&emsp;Number of points along transformation axis in the input to use.<br>&emsp;&emsp;If `n` is smaller than the length of the input, the input is cropped.<br>&emsp;&emsp;If it is larger, the input is padded with zeros. If `n` is not given,<br>&emsp;&emsp;the length of the input along the axis specified by `axis` is used.<br>    axis : int, optional<br>&emsp;&emsp;Axis over which to compute the FFT. If not given, the last axis is<br>&emsp;&emsp;used.<br>    norm : {None, "ortho"}, optional<br>&emsp;&emsp;.. versionadded:: 1.10.0<br>    <br>&emsp;&emsp;Normalization mode (see `numpy.fft`). Default is None.<br>    <br><a name="Returns"></a></div></div><h3>Returns</h3><div style="background-color:#f2eadd;"><div style="margin-left:1.5em;">    out : complex ndarray<br>&emsp;&emsp;The truncated or zero-padded input, transformed along the axis<br>&emsp;&emsp;indicated by `axis`, or the last one if `axis` is not specified.<br>&emsp;&emsp;If `n` is even, the length of the transformed axis is ``(n/2)+1``.<br>&emsp;&emsp;If `n` is odd, the length is ``(n+1)/2``.<br>    <br><a name="Raises"></a></div></div><h3>Raises</h3><div style="background-color:#f2eadd;"><div style="margin-left:1.5em;">    IndexError<br>&emsp;&emsp;If `axis` is larger than the last axis of `a`.<br>    <br><a name="See Also"></a></div></div><h3>See Also</h3><div style="background-color:#f2eadd;"><div style="margin-left:1.5em;">    numpy.fft : For definition of the DFT and conventions used.<br>    irfft : The inverse of `rfft`.<br>    fft : The one-dimensional FFT of general (complex) input.<br>    fftn : The *n*-dimensional FFT.<br>    rfftn : The *n*-dimensional FFT of real input.<br>    <br><a name="Notes"></a></div></div><h3>Notes</h3><div style="background-color:#f2eadd;"><div style="margin-left:1.5em;">    When the DFT is computed for purely real input, the output is<br>    Hermitian-symmetric, i.e. the negative frequency terms are just the complex<br>    conjugates of the corresponding positive-frequency terms, and the<br>    negative-frequency terms are therefore redundant.  This function does not<br>    compute the negative frequency terms, and the length of the transformed<br>    axis of the output is therefore ``n//2 + 1``.<br>    <br>    When ``A = rfft(a)`` and fs is the sampling frequency, ``A[0]`` contains<br>    the zero-frequency term 0*fs, which is real due to Hermitian symmetry.<br>    <br>    If `n` is even, ``A[-1]`` contains the term representing both positive<br>    and negative Nyquist frequency (+fs/2 and -fs/2), and must also be purely<br>    real. If `n` is odd, there is no term at fs/2; ``A[-1]`` contains<br>    the largest positive frequency (fs/2*(n-1)/n), and is complex in the<br>    general case.<br>    <br>    If the input `a` contains an imaginary part, it is silently discarded.<br>    <br><a name="Examples"></a></div></div><h3>Examples</h3><div style="background-color:#f2eadd;"><div style="margin-left:1.5em;">    >>> np.fft.fft([0, 1, 0, 0])<br>    array([ 1.+0.j,  0.-1.j, -1.+0.j,  0.+1.j]) # may vary<br>    >>> np.fft.rfft([0, 1, 0, 0])<br>    array([ 1.+0.j,  0.-1.j, -1.+0.j]) # may vary<br>    <br>    Notice how the final element of the `fft` output is the complex conjugate<br>    of the second element, for real input. For `rfft`, this symmetry is<br>    exploited to compute only the non-negative frequency terms.<br><br></div></div><br><br><br>             </div>      </div>      <div class="col-md-3" role="complementary">             <br><p>             </p>      </div></div></body></html>